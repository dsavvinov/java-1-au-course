# Binary compatibility

## Идея

В данном задании вам предлагается сэмулировать 
ситуацию, в которой необходимо задуматься о backward/forward compatibility.

Для этого рассмотрим игрушечный пример. Пусть у вас есть простое приложение, 
которое занимается тем, что пишет и читает в/из файла некоторые "сообщения" (из 
чего они состоят -- ниже).

Вам необходимо будет написать две версии этого приложения, а потом добиться того,
чтобы они "дружили"

## Задания

1. Реализуйте "Версию 1.0" вашего приложения: сообщения состоят ровно из одного
текстового поля (см. интерфейсы `MessageV1`, `SerializerV1`)  
    - Должны проходить тесты из файла `VersionOneTest`
    - Используйте библиотеку *Protocol Buffers* для сериализации/десериализации  
      **Hint:** `protoc <ваш файл> --java_out=<путь до папки 'src/main/java'>`

2. Реализуйте "Версию 2.0" вашего приложения: добавьте в сообщение одно поле,  
хранящее целое число.
   - Должны проходить тесты из файла `VersionTwoTest`
   - Не модифицируйте старый `.proto` файл, а создайте новый  
   - Рекомендуется не пытаться переиспользовать никакой код из v1.0: представьте, 
     что это два разных приложения. 

3. Добейтесь того, чтобы проходили следующие тесты из файла `CrossVersionTest`:
   - `testBackwardCompatiblity` -- проверка на то, что сериализатор версии 2.0 
   может прочитать старые сообщения версии 1.0  
   Заметьте, что в таком сценарии приложению 2.0 придется откуда-то выдумать 
   значения тех полей, про которые приложение 1.0 не знало.
   - `testForwarwdCompatibility` -- проверка на то, что сериализатор версии 1.0
    может прочитать известный ему кусок нового сообщения (т.е. хотя бы текст)
   
4. (*) Добейтесь того, чтобы проходил тест `CrossVersionTests.oldSerializerDoesntLoseInformation()`.  
Данный тест проверяет, что если в руки старому сериализатору попадает новое сообщение, то он не выкидывает
неизвестные ему куски и способен вернуть их обратно.

5. (**) Исправьте код сериализатора 1.0 таким образом, чтобы он умел понимать, что ему на вход
поступило сообщение более новой версии (например, можно в таком случае выдавать вежливый warning
в stdout)  

6. (**) Представим, что в версии 3.0 мы поняли, что размер передавемого текста слишком большой, и хорошо бы передавать
не голый текст, а сжатый каким-нибудь алгоритмом (например, LZW)
   - Опишите, какие есть варианты реализовать это, и к каким последствиям (с точки зрения) 
   совместимости они приводят
   - Как следовало бы подправить реализации версий 1.0 и 2.0, чтобы подобные изменения было
   легче делать?